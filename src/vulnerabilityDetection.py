import subprocess

import requests
from bs4 import BeautifulSoup
import re;
import json
import nvdlib
from packaging import version
import requests
from packaging.version import Version
from packaging.version import Version, parse


#if the package is pre-release version and nvd database does not give any result then get the stable version and check
def is_rc_version(version):
    """Detect if a version is a pre-release (rc, beta, alpha, etc.)"""
    return bool(re.search(r"(rc|beta|alpha|preview|snapshot|nightly|m[0-9]+)", version, re.IGNORECASE))


def direct_update_for_rc_version(package_name, package_version, package_manager):
    """Fetch the latest stable version if the current version is a pre-release"""
    if is_rc_version(package_version):
        try:
            if package_manager == "npm":
                # Get all versions from npm
                result = subprocess.run(
                    [r"C:\Program Files\nodejs\npm.cmd", "show", package_name, "versions", "--json"],
                    capture_output=True, text=True, check=True)

                versions = json.loads(result.stdout)
                stable_versions=[]
                for version in versions:
                    if not is_rc_version(version):
                        stable_versions.append(version)

                latest_stable_version = stable_versions[-1] if stable_versions else None

                if latest_stable_version:
                    return f" Updated to latest stable version: {latest_stable_version}"
                else:
                    return f" No stable version found for {package_name}."
            else:
                return f" Unsupported package manager: {package_manager}"
        except Exception as e:
            return f" Error fetching version for {package_name}: {e}"
    else:
        return f" {package_name} ({package_version}) is already a stable version."



def get_next_patch_version(current_version):
    version = Version(current_version)
    next_version = f"{version.major}.{version.minor}.{version.micro + 1}"
    return next_version


def is_valid_cpe(cpe_entry, target_product, package_version, start_limit, end_limit):
    # Step 1: Extract product name dynamically from criteria
    criteria = cpe_entry.get("criteria", "")
    parts = criteria.split(":")  # CPE format: cpe:2.3:a:<vendor>:<product>:...

    if len(parts) < 4 or parts[2] != "a":  # Ensure it's an application
        return False, None

    product_name = parts[3].lower()

    # Step 2: Ensure the extracted product matches the target product
    if target_product.lower() not in product_name and product_name not in target_product.lower():
        return False, None

    # Step 3: Ensure the entry is marked as vulnerable
    if not cpe_entry.get("vulnerable", False):
        return False, None

    # Step 4: Extract version constraints
    version_start = cpe_entry.get("start")
    version_end = cpe_entry.get("end")

    # Convert package_version and CPE versions to comparable format
    package_version = Version(package_version)
    if version_start != "N/A":
        version_start = Version(version_start)
    if version_end != "N/A":
        version_end = Version(version_end)

    # Version checks based on inclusion/exclusion limits
    if version_start == 'N/A' and version_end:
        if end_limit == "exclude":
            if package_version < version_end:
                print("Vulnerable for this CPE:", criteria)
                return True, version_end
            else:
                return False, None
        elif end_limit == "include":
            if package_version <= version_end:
                return True, version_end
            else:
                return False, None

    if version_start != 'N/A' and version_end != 'N/A':
        if start_limit == 'include' and end_limit == 'include':
            if version_start <= package_version <= version_end:
                print(version_start)
                print(version_end)
                next_safe_version=get_next_patch_version(version_end)
                return True, next_safe_version
            else:
                return False, None
        elif start_limit == 'exclude' and end_limit == 'exclude':
            if version_start < package_version < version_end:
                print(version_start)
                print(version_end)
                return True, version_end
            else:
                return False, None
        if start_limit == 'include' and end_limit == 'exclude':
            if version_start <= package_version < version_end:
                print(version_start)
                print(version_end)
                next_safe_version = version_end
                return True, next_safe_version
            else:
                return False, None
        elif start_limit == 'exclude' and end_limit == 'include':
            if version_start < package_version <= version_end:
                print(version_start)
                print(version_end)
                next_safe_version=get_next_patch_version(version_end)
                return True, next_safe_version
            else:
                return False, None

    if version_end == 'N/A' and version_start:
        if start_limit == "include":
            if package_version >= version_start:
                print(version_start)
                print(version_end)
                return True, version_start
            else:
                return False, None
        elif start_limit == 'exclude':
            if package_version > version_start:
                print(version_start)
                print(version_end)
                return True, version_start
            else:
                return False, None

    return False, None



# Function to get the CPE number of a vulnerable package and check the base score
def get_cpe_number_and_check_vulnerability(package_name, package_version):
    status = "not vulnerable"
    start_limit = ""
    end_limit = ""
    nvd_api = 'https://services.nvd.nist.gov/rest/json/cves/2.0'

    try:
        response = requests.get(f"{nvd_api}?keywordSearch={package_name}+{package_version}")

        if response.status_code == 200:
            nvd_data = response.json()
            vulnerabilities = nvd_data.get("vulnerabilities", [])

            for vulnerability in vulnerabilities:
                cve_id = vulnerability.get('cve', {}).get('id', 'Unknown CVE')
                configurations = vulnerability.get('cve', {}).get('configurations', [])

                # Extracting the CVSS base score
                base_score = 0
                cvss_metrics = vulnerability.get('cve', {}).get('metrics', {}).get('cvssMetricV31', [])

                for metric in cvss_metrics:
                    cvss_data = metric.get('cvssData', {})
                    severity=cvss_data.get('baseSeverity')
                    base_score = max(base_score, cvss_data.get('baseScore', 0))

                # print(f"CVE: {cve_id}, Base Score: {base_score}")

                # If baseScore is >=7, consider vulnerable directly
                if base_score >= 7:
                    print(f"Base Score is {base_score}, marking {package_name} as vulnerable!")
                    return "Vulnerable"

                # Checking version-based vulnerabilities
                for config in configurations:
                    for node in config.get('nodes', []):
                        for match in node.get('cpeMatch', []):
                            cpe23Uri = match.get('criteria', '')
                            if match.get('versionStartIncluding'):
                                start_limit = "include"
                                start = match.get('versionStartIncluding')
                            else:
                                start_limit = "exclude"
                                start = match.get('versionStartExcluding', 'N/A')
                            if match.get('versionEndIncluding'):
                                end_limit = "include"
                                end = match.get('versionEndIncluding')
                            else:
                                end_limit = "exclude"
                                end = match.get('versionEndExcluding', 'N/A')

                            if start == 'N/A' and end == 'N/A':
                                continue
                            vulnerability = match.get('vulnerable')

                            cpe_entry = {
                                "vulnerable": vulnerability,
                                "criteria": cpe23Uri,
                                "start": start,
                                "end": end
                            }

                            isValid = is_valid_cpe(cpe_entry, package_name, package_version, start_limit, end_limit)
                            status, safe_version = isValid  # No more errors
                            if status:
                                status1 = "Vulnerable"
                                result = {
                                    "vulnerability_status": status1,
                                    "severity": severity,
                                    "cpe_affected": cve_id,
                                    "base_score": base_score,
                                    "next_safe_version": safe_version
                                }

                                return result

        else:
            print('Error:', response.status_code)
            return None

    except requests.exceptions.RequestException as e:
        print('Error:', e)
        return None

    return status


#understand how dependabot works and how our approach is different
#Find outWhat dependabot is not doing that we are doing


if __name__ == "__main__":
  print(get_cpe_number_and_check_vulnerability('Apache Log4j','2.17.0'))
#   # print(direct_update_for_rc_version("lodash", "1.0.0-rc.1", "npm"))
#   # # print(direct_update_for_rc_version("react", "18.0.0", "npm")
#   # get_cpe();